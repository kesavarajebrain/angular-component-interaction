<div class="container mt-3">
    <p routerLink="/">
        <a class="pe-auto text-secondary text-decoration-none"> <-Back </a>
    </p>
    <h4>Web Socket</h4>
    <p>A WebSocket is a protocol that creates a persistent, two-way connection between a client (browser/app) and a
        server.
        WebSocket à®à®©à¯à®ªà®¤à¯ à®’à®°à¯ communication protocol (à®¤à¯Šà®Ÿà®°à¯à®ªà¯ à®µà®¿à®¤à®¿à®®à¯à®±à¯ˆ).</p>
    <p>à®‡à®¤à®©à¯ à®®à¯à®•à¯à®•à®¿à®¯ à®µà¯‡à®²à¯ˆ: <br>
        ğŸ‘‰ Browser / App (Client) à®®à®±à¯à®±à¯à®®à¯ Server à®‡à®µà®±à¯à®±à¯à®•à¯à®•à¯ à®‡à®Ÿà¯ˆà®¯à®¿à®²à¯ à®’à®°à¯ à®¨à¯€à®£à¯à®Ÿ à®¨à¯‡à®°à®®à¯ à®¤à®¿à®±à®¨à¯à®¤à¯‡ à®‡à®°à¯à®•à¯à®•à¯à®®à¯ connection
        à®‰à®°à¯à®µà®¾à®•à¯à®•à¯à®µà®¤à¯. <br>
        ğŸ‘‰ à®…à®¤à®¿à®²à¯ à®‡à®°à¯ à®ªà®•à¯à®•à®®à¯à®®à¯ (two-way) à®à®ªà¯à®ªà¯‹à®¤à¯ à®µà¯‡à®£à¯à®Ÿà¯à®®à®¾à®©à®¾à®²à¯à®®à¯ data à®…à®©à¯à®ªà¯à®ª à®®à¯à®Ÿà®¿à®¯à¯à®®à¯.</p>
    <p>âœ… WebSocket à®à®©à¯à®ªà®¤à¯ à®’à®°à¯ protocol - (à®…à®¤à®¾à®µà®¤à¯ â€“ client à®®à®±à¯à®±à¯à®®à¯ server à®à®ªà¯à®ªà®Ÿà®¿ à®ªà¯‡à®š à®µà¯‡à®£à¯à®Ÿà¯à®®à¯ à®à®©à¯à®ªà®¤à®±à¯à®•à®¾à®© à®µà®¿à®¤à®¿) <br>
        âœ… à®…à®¤à¯ persistent connection à®‰à®°à¯à®µà®¾à®•à¯à®•à¯à®®à¯ - (à®’à®°à¯ à®®à¯à®±à¯ˆ connect à®†à®© à®ªà®¿à®±à®•à¯ close à®†à®•à®¾à®®à®²à¯ à®¤à¯Šà®Ÿà®°à¯à®¨à¯à®¤à¯ open à®†à®• à®‡à®°à¯à®•à¯à®•à¯à®®à¯)
        <br>
        âœ… à®…à®¤à¯ two-way connection - (client â†’ server à®®à®Ÿà¯à®Ÿà¯à®®à®²à¯à®², server â†’ client à®•à¯‚à®Ÿ à®‰à®Ÿà®©à¯‡ message à®…à®©à¯à®ªà¯à®ª à®®à¯à®Ÿà®¿à®¯à¯à®®à¯)
    </p>
</div>
<div class="container alert alert-info">
    <div class="row">
        <div class="col">
            <pre>
<b>à®šà®¾à®¤à®¾à®°à®£ HTTP:</b>
    ğŸ‘¤ Client: â€œUpdate à®‡à®°à¯à®•à¯à®•à®¾?â€
    ğŸ–¥ Server: â€œà®‡à®²à¯à®²â€
    (Connection close)

à®®à¯€à®£à¯à®Ÿà¯à®®à¯â€¦
    ğŸ‘¤ Client: â€œUpdate à®‡à®°à¯à®•à¯à®•à®¾?â€
    ğŸ–¥ Server: â€œà®‡à®°à¯à®•à¯à®•à¯!â€

ğŸ‘‰ à®‡à®¤à¯ slow + wasteful.
            </pre>
            <hr>
            <p><b>ğŸŒ HTTP (Traditional Web Requests)</b></p>
            <p>HTTP works in a requestâ€“response model.</p>
            <p>Flow:</p>
            <ul>
                <li>1ï¸âƒ£ Client sends request
                </li>
                <li>2ï¸âƒ£ Server processes it
                </li>
                <li>3ï¸âƒ£ Server sends response
                </li>
                <li>4ï¸âƒ£ Connection closes
                </li>
            </ul>
            <b>If the client wants new data later â†’ it must send another request.
            </b>
            <ul>
                <li> <b>âŒ Problems with HTTP for real-time:</b>
                </li>
                <li> Wastes bandwidth
                </li>
                <li>Slower updates
                </li>
                <li>Creates many requests
                </li>
                <li>Server load increases
                </li>
                <li>Not truly real-time
                </li>
            </ul>
        </div>
        <div class="col">
            <pre>
<b>WebSocket:</b>
    ğŸ‘¤ Client connect à®†à®•à¯à®±à®¾à®©à¯ ğŸ”Œ
    ğŸ–¥ Server: â€œOK ğŸ‘â€

à®ªà®¿à®±à®•à¯â€¦
    ğŸ–¥ Server: â€œNew message à®µà®¨à¯à®¤à¯à®šà¯à®šà¯!â€
    ğŸ‘¤ Client: à®‰à®Ÿà®©à¯‡ receive à®ªà®£à¯à®£à®¿à®•à¯à®•à¯à®±à®¾à®©à¯ ğŸ˜

ğŸ‘‰ à®‡à®¤à¯à®¤à®¾à®©à¯ WebSocket magic âœ¨
            </pre>
            <hr>
            <p><b>ğŸ”Œ WebSocket</b></p>
            <p>WebSocket creates a single long-lived connection.</p>
            <p>Once connected:</p>
            <ul>
                <li>âœ” Client can send anytime
                </li>
                <li>âœ” Server can push anytime
                </li>
                <li>âœ” No need to re-open connection
                </li>
                <li>âœ” Very low overhead
                </li>
                <li>âœ” Near-instant delivery
                </li>
            </ul>
            <pre>ğŸ“Œ Example (WebSocket)

Chat app:
Client connects once.

Then:
Server â†’ â€œNew message arrived ğŸ’¬â€
Client receives immediately.

No repeated asking.
            </pre>
        </div>
    </div>
</div>
<div class="container alert alert-primary">
    <div class="row">
        <div class="col">
            <h6>ğŸ§  When Should You Use WebSockets?</h6>
            <p> Use WebSockets when:
            </p>
            <ul>
                <li>âœ… You need instant updates
                </li>
                <li>âœ… Many small messages
                </li>
                <li>âœ… Live dashboards
                </li>
                <li>âœ… Multiplayer games
                </li>
                <li>âœ… Collaboration tools
                </li>
                <li>âœ… Chat systems
                </li>
                <li>âœ… IoT telemetry
                </li>
            </ul>
        </div>
        <div class="col">
            <p> Donâ€™t use them for:
            </p>
            <ul>
                <li>âŒ Simple CRUD APIs
                </li>
                <li>âŒ Page loads
                </li>
                <li>âŒ One-time fetch data
                </li>
            </ul>
        </div>
    </div>
</div>
<div class="container card alert alert-success">
    <div class="row">
        <h4 class="title">ğŸ’¬ Angular WebSocket Demo</h4>
        <div class="connection-status" [ngClass]="connectionStatus">
            <span *ngIf="connectionStatus === 'connected'">ğŸŸ¢ Connected</span>
            <span *ngIf="connectionStatus === 'reconnecting'">ğŸŸ¡ Reconnectingâ€¦</span>
            <span *ngIf="connectionStatus === 'disconnected'">ğŸ”´ Disconnected</span>
        </div>
        <!-- JOIN -->
        <div *ngIf="!joined" class="join-box">
            <div class="row">
                <div class="col-4">
                    <input [(ngModel)]="username" class="form-control" placeholder="Enter your name" />
                </div>
                <div class="col">
                    <button class="btn btn-info rounded" (click)="joinChat()">Join Chat</button>
                </div>
            </div>
        </div>
        <div class="chat-container">
            <!-- CHAT -->
            <div *ngIf="joined" class="chat-box">
                <!-- Messages -->
                <div class="messages" #scrollMe>
                    <ng-container *ngFor="let msg of messages; let i = index">
                        <!-- Day Separator -->
                        <div *ngIf="isNewDay(i)" class="day-separator">
                            {{ getDayLabel(msg.timestamp ?? 0) }}
                        </div>
                        <!-- Message Wrapper -->
                        <div class="message-row" [class.mine-row]="msg.user === username">
                            <!-- Bubble -->
                            <div class="bubble" [class.mine]="msg.user === username">
                                <div class="sender">{{ msg.user }}</div>
                                <div class="text">{{ msg.text }}</div>
                                <div class="meta">
                                    <span class="time">
                                        {{ msg.timestamp | date:'shortTime' }}
                                    </span>
                                    <span class="ticks" *ngIf="msg.user === username">
                                        âœ”âœ”
                                    </span>
                                </div>
                                <!-- Reactions -->
                                <div class="reactions">
                                    <!-- Existing -->
                                    <span class="reaction" *ngFor="let r of msg.reactions | keyvalue"
                                        (click)="react(msg, r.key)">
                                        {{ r.key }} {{ r.value.length }}
                                        <!-- Hover tooltip -->
                                        <span class="reaction-tooltip">
                                            <div class="reactor" *ngFor="let user of r.value">
                                                {{ user }}
                                            </div>
                                        </span>
                                    </span>
                                    <!-- Quick -->
                                    <span class="reaction add" (click)="react(msg,'ğŸ‘')">ğŸ‘</span>
                                    <span class="reaction add" (click)="react(msg,'â¤ï¸')">â¤ï¸</span>
                                    <span class="reaction add" (click)="react(msg,'ğŸ˜‚')">ğŸ˜‚</span>
                                    <span class="reaction add" (click)="react(msg,'ğŸ˜®')">ğŸ˜®</span>
                                </div>
                            </div>
                        </div>
                    </ng-container>
                </div>
                <!-- Input -->
                <div class="typing-indicator" *ngIf="typingUser">
                    {{ typingUser }} is typing...
                </div>
                <input class="chat-input" [(ngModel)]="message" placeholder="Type a message" (keydown.enter)="send()"
                    (input)="notifyTyping()" />
            </div>
        </div>
    </div>
</div>
<div class="container card alert alert-warning">
    <div class="row">
        <h5>How it works?</h5>
        <div class="col">
            <pre>
<b>ğŸ§  Big Picture First (When you click â€œSendâ€ in Angular)</b> 
 Component
   â†“
SocketService
   â†“
Browser WebSocket
   â†“
Node WS Server
   â†“
Broadcast loop
   â†“
All connected browser sockets
   â†“
SocketService (each tab)
   â†“
Component subscriptions
   â†“
UI updates
        </pre>
            <b>ğŸš€ STEP 1 â€” Component sends message</b><br>
            In your component:
            <pre>

send() &#123;
  this.socketService.send(&#123;
    type: 'message',
    user: this.username,
    text: this.message
  &#125;);
&#125;
What happens:
â€¢ You click Enter
â€¢ send() runs
â€¢ calls service method
â€¢ passes a JS object
<b>At this point it is not WebSocket yet â€” just a normal function call.</b>
</pre>

            <b>ğŸ”Œ STEP 2 â€” Service receives that object</b><br>
            Inside SocketService:
            <pre>

send(event: OutgoingEvent) &#123;
  this.socket$.next(event);
&#125;
This is crucial.
<b>socket$ is an RxJS WebSocketSubject.</b>

means:
ğŸ‘‰ serialize the object
ğŸ‘‰ push it into browser WebSocket
ğŸ‘‰ send it over network to server
</pre>
            <b>ğŸŒ STEP 3 â€” Browser sends frame to Node</b><br>
            The browserâ€™s WebSocket connection sends that frame to: ws://localhost:8080
            <pre>

No HTTP.
No REST.
No polling.

Just a live TCP connection.
</pre>
            <b>ğŸ–¥ï¸ STEP 4 â€” Node server receives message</b><br>
            In server.js:
            <pre>
socket.on&lpar;'message', data => &#123;
<b>This fires only because the browser sent something.</b>
<b>data</b> is raw bytes.
</pre>
            <hr>
            <pre>
ğŸ”¥ One sentence you should remember forever:

socket$.next() = send to server.
socket.on('message') = receive at server.
client.send() = server sending back.
socket$.subscribe() = receive in browser.
</pre>
        </div>
        <div class="col">
            <b>ğŸ” STEP 5 â€” Server parses payload</b>
            <pre>
const payload = JSON.parse(data.toString());

Now server has the same object:
&#123; type:'message', user:'Raj', text:'Hi' &#125;
 </pre>
            <b>ğŸ§  STEP 6 â€” Server enriches message</b><br>
            Server adds authority fields:
            <pre>
payload.id = crypto.randomUUID();
payload.timestamp = Date.now();

Now message becomes:
&#123; type:'message', id:'123', user:'Raj', text:'Hi', timestamp:... &#125;
 </pre>
            <b>ğŸ“¡ STEP 7 â€” Server broadcasts</b>
            <pre>
wss.clients.forEach(client => &#123;
  client.send(JSON.stringify(payload));
&#125;);
This loops through:
ğŸ‘‰ every connected browser socket.

Important:
The sender also receives their own message back.
Thatâ€™s how delivery ticks work.
 </pre>
            <b>ğŸŒ STEP 8 â€” Browser receives message</b><br>
            In every tab, the RxJS socket fires:
            <pre>
this.socket$.subscribe( &#123; next: ev => ...  &#125;)
<b>That ev is the parsed object from server.</b>
 </pre>
            <b>ğŸ” STEP 9 â€” Service pushes into stream$</b>
            <pre>
this.stream$.next(ev);
Now the service broadcasts to all Angular components.
 </pre>
            <b>ğŸ§© STEP 10 â€” Component subscription runs</b><br>
            In your component:
            <pre>
    this.socketService.events$().subscribe(ev =>  &#123; ...  &#125;);

This triggers instantly.
Now Angular:
â€¢ pushes message into messages[]
â€¢ scrolls UI
â€¢ shows reaction counts
â€¢ updates ticks
 </pre>
            <b>ğŸ¯ THAT IS THE FULL LOOP.</b>
            <p>One message: Component â†’ Service â†’ Browser Websocket â†’ Server â†’ All WebSocket â†’ Service â†’ Component â†’ UI.
            </p>
            <pre>
<b>ğŸ§  KEY INSIGHT YOU JUST UNLOCKED</b>
* There is no REST call here.
* No HttpClient.
* No request/response.
* It is a continuous pipe.
* Server is listening.
* Clients are listening.
* Anyone can push at any time.

ğŸ” Why This Works for Multiple Tabs

Each tab:
âœ” opens its own socket (each browser has own sockets)
âœ” server stores all sockets in wss.clients
âœ” broadcast sends to all , So two tabs behave like two phones.
</pre>
        </div>
    </div>
</div>
<div class="container card alert alert-light">
    <div class="row">
        <h4>Code Breakup</h4>
        <div class="col">
            <b>Server.js</b>
            <pre>

const WebSocket = require('ws');
const crypto = require('crypto');

const wss = new WebSocket.Server(&#123; port: 8080 &#125; );

console.log('âœ… WS Chat Server running on ws://localhost:8080');

wss.on('connection', socket => &#123; 

socket.on('message', data => &#123; 

const payload = JSON.parse(data.toString());

// Add id + timestamp for messages
if (payload.type === 'message') &#123; 
payload.id = crypto.randomUUID();
payload.timestamp = Date.now();
&#125; 

// Broadcast EVERYTHING
wss.clients.forEach(client => &#123; 
if (client.readyState === WebSocket.OPEN) &#123; 
client.send(JSON.stringify(payload));
&#125; 
&#125; );
&#125; );
&#125; );
        </pre>
            <hr>
            <p><b class="text-danger"> ğŸ§  Step 7</b> - Smart Logic Block â€” Message Enrichment - <b>This is SUPER
                    important.</b></p>
            <pre>
if (payload.type === 'message') &#123;
  payload.id = crypto.randomUUID();
  payload.timestamp = Date.now();
&#125;
</pre>
            <pre>
<b>Client sends:</b>
&#123; type:'message', user:'Raj', text:'Hi' &#125;

<b>Server upgrades it into:</b>
&#123;
  type:'message',
  id:'uuid',
  user:'Raj',
  text:'Hi',
  timestamp: 1723...
&#125;

Why server does this?
Because: <b>ğŸ‘‰ server is the source of truth</b>
</pre>
            <p><b class="text-danger">ğŸ“¡ Step 8</b> - Broadcast to ALL connected clients
                <b>wss.clients.forEach&lpar;client => &#123;</b>
            </p>
            <b>wss.clients = Set of every connected socket.</b>
            <pre>
Think: we opened multiple socket connections:
[ tab1, tab2, mobile, desktop ]

ğŸŸ¢ And Only send if connection open
if (client.readyState === WebSocket.OPEN) &#123;
</pre>
        </div>
        <div class="col">
            <p><b class="text-danger">ğŸ“¦ Step 1</b> â€” Import WebSocket library - <b>const WebSocket = require('ws');</b>
            </p>
            <pre>
Imports the ws npm package â€” a WebSocket implementation for Node.js.

Why we need it:
Node doesnâ€™t have built-in WebSocket servers like browsers.
Without this â†’ âŒ no real-time server.</pre>
            <p><b class="text-danger">ğŸ” Step 2</b> â€” Import crypto - <b>const crypto = require('crypto');</b></p>
            <pre>
We use it only for:
crypto.randomUUID()
Which generates: ğŸ‘‰ globally unique message IDs.
</pre>
            <b> Why IDs matter:
            </b>
            <ul>
                <li>reactions attach to right message</li>
                <li>read receipts</li>
                <li>edits</li>
                <li>deletes</li>
            </ul>
            <p><b class="text-danger">ğŸ—ï¸ Step 3</b> â€” Create WebSocket Server - <b>const wss = new
                    WebSocket.Server(&#123; port: 8080 &#125;);</b>
            </p>
            <p>wss = WebSocket Server.</p>
            <p><b class="text-danger">ğŸ”Œ Step 4</b> - Listen for new client connections - <b> wss.on &lpar;'connection',
                    socket => &#123;</b></p>
            <b>What is this?</b>
            <ul>
                <li>This fires every time: ğŸ‘‰ a browser/tab/app connects via WebSocket.</li>
                <li><b>Each browser tab = one socket.</b></li>
            </ul>
            <pre>
â€¢ socket = that specific client
â€¢ you can listen to events from it
â€¢ send data to it
â€¢ close it</pre>
            <p><b class="text-danger">ğŸ” Step 5</b> - Listen for messages from THAT client -
                <b>socket.on&lpar;'message', data => &#123;</b>
            </p>
            <pre>
What is this? - Triggered whenever this client sends something.
* Not polling.
* Not HTTP.
* Not refresh.
<b>>>Pure push.</b>
</pre>
            <p><b class="text-danger">ğŸ” Step 6</b> - Parse JSON <b>const payload = JSON.parse(data.toString());</b></p>
            <pre>
Why? - Clients send:
JSON.stringify(&#123;...&#125;)
Server receives bytes.
We convert: Buffer â†’ string â†’ object
Now we can inspect:
â€¢ payload.type
â€¢ payload.user
â€¢ payload.text
        </pre>
            <p><b class="text-danger"> ğŸš€ Step 9</b> - Send payload <b>client.send(JSON.stringify(payload));</b></p>
            <pre>
Turn object â†’ JSON â†’ push to socket.
This instantly delivers to:
â€¢ sender
â€¢ receiver
â€¢ all others
</pre>
        </div>
        <div>
            <pre>
ğŸ” MEMORY HOOK (Never Forget This)
Remember WebSocket servers like:

ğŸ”Œ Accept â†’ Listen â†’ Enrich â†’ Broadcast

Every real WS backend does:
1ï¸âƒ£ on connection
2ï¸âƒ£ on message
3ï¸âƒ£ validate / enrich
4ï¸âƒ£ send to others
            </pre>
        </div>
    </div>
</div>
<div class="container alert alert-secondary">
    <div class="row">
        <b>Socket.service.ts</b>
        <div class="col">
            <pre>
import &#123; Injectable  &#125; from '&#64;angular/core';
import &#123; webSocket, WebSocketSubject  &#125; from 'rxjs/webSocket';
import &#123; Subject, Observable, timer  &#125; from 'rxjs';
import  &#123;
OutgoingEvent,
IncomingEvent
&#125; from './socket.types';

&#64;Injectable( &#123; providedIn: 'root'  &#125;)
export class SocketService  &#123;

private socket$!: WebSocketSubject&lpar;any>;

private stream$ = new Subject&lpar;IncomingEvent>();

private reconnectDelay = 2000;
private connected = false;
private status$ = new Subject&lpar;'connected' | 'disconnected' | 'reconnecting'>();

statusChanges$()  &#123;
return this.status$.asObservable();
&#125;

connect()  &#123;
if (this.connected) return;

console.log('ğŸ”Œ Connecting WS...');

this.socket$ = webSocket( &#123;
url: 'ws://localhost:8080',
serializer: msg => JSON.stringify(msg),
deserializer: msg => JSON.parse(msg.data),
openObserver:  &#123;
next: () =>  &#123;
    console.log('âœ… WS connected');
    this.connected = true;
    this.reconnectDelay = 2000;
    this.status$.next('connected');   // ğŸ‘ˆ
    &#125;
&#125;,
closeObserver:  &#123;
next: () =>  &#123;
    console.warn('âš ï¸ WS closed');
    this.connected = false;
    this.status$.next('reconnecting');  // ğŸ‘ˆ
    this.scheduleReconnect();
    &#125;
&#125;
&#125;);

this.socket$.subscribe( &#123;
next: ev => this.stream$.next(ev as IncomingEvent),
error: err =>  &#123;
console.error('WS error', err);
this.connected = false;
this.status$.next('reconnecting');   // ğŸ‘ˆ
this.scheduleReconnect();
&#125;
&#125;);
&#125;

private scheduleReconnect()  &#123;
console.log(`ğŸ” Reconnecting in $ &#123;this.reconnectDelay &#125;ms...`);

timer(this.reconnectDelay).subscribe(() =>  &#123;
this.connect()
&#125;);

// backoff up to 10s
this.reconnectDelay = Math.min(
this.reconnectDelay * 1.5,
10000
);
&#125;

send(event: OutgoingEvent)  &#123;
if (!this.socket$ || !this.connected)  &#123;
console.warn('âš ï¸ Not connected yet');
return;
&#125;

this.socket$.next(event);
&#125;

events$(): Observable&lpar;IncomingEvent>  &#123;
return this.stream$.asObservable();
&#125;

close()  &#123;
this.socket$?.complete();
this.connected = false;
this.status$.next('disconnected');   // ğŸ‘ˆ
&#125;
&#125;
</pre>
            <hr>
            <p><b>Error handler</b></p>
            <pre> error: err => &#123;

If connection fails:
â€¢ mark disconnected
â€¢ show UI
â€¢ retry later
</pre>
            <p><b>ğŸ” scheduleReconnect()</b></p>
            <b>This is the resilience (à®®à¯€à®³à¯à®¤à®©à¯à®®à¯ˆ) engine. (if the connection is lost again its trying to reconnect)</b>
            <pre>

timer(this.reconnectDelay).subscribe(() => &#123;
  this.connect();
&#125;);

Wait â†’ then retry.
</pre>
            <p><b>ğŸ“¤ send()</b></p>
            <pre>
send(event: OutgoingEvent)
Only sends client â†’ server events.

if (!this.socket$ || !this.connected)
Guard:
âœ” avoid crash
âœ” avoid silent fail
âœ” show warning
</pre>
            <p><b>ğŸ“¥ events$()</b></p>
            <pre>
events$(): Observable&#11164;IncomingEvent>
Components subscribe here.
They never touch socket directly.
</pre>
            <p><b>ğŸ§¹ close()</b></p>
            <pre>
this.socket$?.complete();
Closes connection intentionally.

this.status$.next('disconnected');
Update UI.
</pre>
        </div>
        <div class="col">
            <p>If server.js is the engineâ€¦ <b>ğŸ‘‰ SocketService is the driver + airbag + GPS + recovery system.
                </b></p>
            <pre>
ğŸ§  Big Picture Role of SocketService
This service is:
ğŸ‘‰ a singleton WebSocket manager
ğŸ‘‰ shared by all components
ğŸ‘‰ hides raw socket complexity
ğŸ‘‰ exposes clean APIs:
</pre>
            <p><b class="text-danger">Step 1</b>ğŸ“¦ Imports Explained - <b>import &#123; webSocket, WebSocketSubject
                    &#125; from 'rxjs/webSocket';</b></p>
            <pre>
This gives:
âœ” observable stream
âœ” automatic JSON handling
âœ” lifecycle hooks
âœ” retry potential
âœ” easy integration
</pre>
            <p><b class="text-danger">Step 2</b>ğŸ“¦ Imports Explained - <b>import &#123; Subject, Observable, timer
                    &#125; from 'rxjs';</b></p>
            <pre>
â€¢ Subject = manual event emitter
â€¢ Observable = read-only stream for UI
â€¢ timer() = delayed execution (used for reconnect)
</pre>
            <p><b class="text-danger">Step 3</b>ğŸ“¦ Imports Explained - <b>import &#123;
                    OutgoingEvent,
                    IncomingEvent
                    &#125; from './socket.types';</b></p>
            <pre>This is a very professional pattern:
ğŸ‘‰ types live in one place
ğŸ‘‰ shared across app
ğŸ‘‰ prevents duplication
ğŸ‘‰ avoids mismatch bugs
</pre>
            <p><b class="text-danger">Step 4</b>ğŸ§  Fields Explained : <b> <br>ğŸ”Œ private socket$!:
                    WebSocketSubject&#11164;any>;</b></p>
            <pre>
<b>This is the actual live connection.</b> 
We typed it any on purpose:
â€¢ outgoing events â‰  incoming events
â€¢ transport layer should be flexible
â€¢ typing enforced at API layer instead
</pre>
            <p><b>ğŸ“¡ private stream$ = new Subject&#11164;IncomingEvent>();</b></p>
            <pre>
Socket â†’ Service â†’ Components.
All messages from server go here.
</pre>
            <p><b>ğŸ” reconnectDelay : private reconnectDelay = 2000;</b></p>
            <pre>
Start reconnecting after 2 seconds.
Prevents hammering the server.
</pre>
            <p><b>ğŸ”µ connected flag : private connected = false;</b></p>
            <pre>
Simple guard:
âœ” prevents duplicate connections
âœ” blocks sending when offline
âœ” helps UI state
</pre>
            <p><b>ğŸ“Š status$ : private status$ = new Subject&#11164;'connected' | 'disconnected' |
                    'reconnecting'>();</b></p>
            <pre>
 This drives UI badges:
ğŸŸ¢ Connected
ğŸŸ¡ Reconnecting
ğŸ”´ Disconnected
Again: Service emits â†’ UI subscribes.
</pre>
            <p><b>ğŸ“¤ statusChanges$()</b></p>
            <pre>
statusChanges$() &#123;
  return this.status$.asObservable();
 &#125;
 Why .asObservable()?
ğŸ‘‰ prevents UI from calling .next()
ğŸ‘‰ only service controls state
</pre>
            <p><b>ğŸ”Œ connect()</b></p>
            <pre>
ğŸ›‘ Prevent duplicate sockets
<b>if (this.connected) return;</b>

Without this:
âŒ multiple sockets open
âŒ duplicate messages
âŒ weird UI bugs
âŒ server overload
</pre>
            <p><b>ğŸŒ Create RxJS socket</b></p>
            <pre>
this.socket$ = webSocket&lpar;&#123;
  url: 'ws://localhost:8080',
<b>Connects to Node server.</b>
</pre>
            <p><b>ğŸ”„ Serializer / Deserializer</b></p>
            <pre>
serializer: msg => JSON.stringify(msg),
deserializer: msg => JSON.parse(msg.data),

Transforms:
Angular object â‡„ WebSocket frame.
</pre>
            <p><b>ğŸŸ¢ openObserver</b></p>
            <pre>
openObserver: &#123;
  next: () => &#123;

<b>Runs when socket opens successfully.</b>
Used to:
    âœ” mark connected
    âœ” reset delay
    âœ” update UI
</pre>
            <p><b>ğŸ”´ closeObserver</b></p>
            <pre>
closeObserver:  &#123;
  next: () =>  &#123;

<b>Runs when socket closes.</b>
This is the trigger for:
ğŸ‘‰ auto-reconnect.
</pre>
            <p><b>ğŸ“© Subscribe to raw socket</b></p>
            <pre>
    this.socket$.subscribe &lpar;&#123;

Why subscribe here?
Because:
ğŸ‘‰ RxJS sockets are lazy
ğŸ‘‰ subscription activates them
Without this, nothing flows.
</pre>
            <p><b>Next handler</b></p>
            <pre>
next: ev => this.stream$.next(ev as IncomingEvent),
<b>Push server data into app stream.</b>
</pre>
        </div>
    </div>
</div>
<div class="container alert alert-primary card">
    <div class="row">
        <b>Web-socket.component.ts</b>
        <div class="col">
            <pre>
                {{tsCode}}
            </pre>
        </div>
        <div class="col">
            <p>If server.js is the engine <br>
                and SocketService is the transmissionâ€¦ <br>
                <b>ğŸ‘‰ this Component is the driver.</b>
            </p>
            <pre>
ğŸ§  ROLE OF THIS COMPONENT
This component:

âœ… shows chat UI
âœ… keeps UI state
âœ… sends user actions to server
âœ… listens to server events
âœ… updates messages
âœ… shows typing
âœ… handles reactions
âœ… scrolls view
âœ… groups days
âœ… shows connection status
âœ… cleans up socket

It never talks directly to WebSocket.
Only to SocketService.
            </pre>
            <p><b>
                    import &#123; Component, OnDestroy, ViewChild, ElementRef &#125; from '&#64;angular/core';</b></p>
            <pre>
â€¢ Component â†’ defines Angular component
â€¢ OnDestroy â†’ cleanup hook
â€¢ ViewChild â†’ access DOM
â€¢ ElementRef â†’ wrapper around DOM element
                    </pre>
            <p><b>import &#123; SocketService &#125; from '../service/socket/socket.service';</b></p>
            <pre>
This is your WebSocket gateway.
Component never touches raw sockets.
</pre>
            <p><b>import &#123; ChatMessage, IncomingEvent &#125; from '../service/socket/socket.types'
                </b></p>
            <pre>
Strong typing for messages/events.
</pre>
            <p><b>import &#123; Subscription &#125; from 'rxjs';</b></p>
            <pre>
    Used so we can unsubscribe on destroy.
</pre>
            <p><b>RouterModule, FormsModule, CommonModule</b></p>
            <pre>
Needed for:
â€¢ routing
â€¢ ngModel
â€¢ ngFor/ngIf
</pre>
            <p><b class="text-danger">Step 1</b> ğŸ§  UI STATE FIELDS </p>
            <b>ğŸ“œ scrollContainer</b><br>
            <b>&#64;ViewChild('scrollMe') private scrollContainer!: ElementRef;</b>
            <pre>
Refers to:
&#11164;div #scrollMe>
Lets TS scroll the chat to bottom.
Without it â†’ chat stays at top.
</pre>
            <p><b>ğŸ‘¤ username / joined</b></p>
            <pre>
username = '';
joined = false;
Controls login UI vs chat UI.
</pre>
            <p><b>ğŸ’¬ message
                    <br>
                    Current input box value.</b></p>
            <pre>
<b>âœï¸ typingUser</b>
Shows:
"Raj is typing..."
Cleared after timeout.
</pre>
            <p><b>ğŸ“¦ messages</b></p>
            <pre>
messages: ChatMessage[] = [];
Holds all chat history.
<b>UI renders this with *ngFor.</b>
</pre>
            <p><b>ğŸ”— sub</b> : RxJS subscription reference for cleanup.</p>
            <p><b>ğŸ“¡ connectionStatus</b></p>
            <pre>
Drives:
ğŸŸ¢ connected
ğŸŸ¡ reconnecting
ğŸ”´ offline
</pre>
            <p><b class="text-danger">Step 2</b> ğŸšª joinChat()</p>
            <p>This is called when user enters name and clicks Join. <br>
                This is where the socket comes alive.</p>
            <pre>
 ğŸ›‘ Guard empty name
if (!this.username.trim()) return;
Prevents anonymous user.

âœ‚ Trim whitespace
Small UX polish.
</pre>
            <p>ğŸ”Œ connect socket <b>this.socketService.connect();</b><br>
                Opens WebSocket connection.</p>
            <p><b>ğŸ“Š subscribe to status</b></p>
            <p>this.socketService.statusChanges$().subscribe(...) <br>
                Updates banner.</p>
            <p><b class="text-danger">Step 3</b> <b>ğŸ“¥ subscribe to events
                    this.sub = this.socketService.events$().subscribe(...)</b></p>
            <p><b>This is the most important line. <br>
                    Everything server sends flows here.</b></p>
            <p><b class="text-danger">Step 4 </b> <b>ğŸ“© EVENT HANDLING</b></p>
            <pre>
ğŸŸ¢ MESSAGE
if (ev.type === 'message') &#123;
Server sent a chat message.

We:
âœ” validate id
âœ” push to array
âœ” clear typing
âœ” scroll
Why id check?
    Because reactions depend on it.
</pre>
            <pre>
âœï¸ TYPING
if (ev.type === 'typing' && ev.user !== this.username)

Ignore own typing.
Show only others.
Clear after 1.5s.
</pre>
            <pre>
ğŸ˜€ REACTION
Find message by id:
this.messages.find(m => m.id === ev.messageId)

Never by index.
Update reactions map.
</pre>
            <pre>
ğŸ“¤ send()
Called when Enter pressed.
Sends minimal payload to server.
<b>Server adds id/time.</b>
</pre>
            <pre>
âœï¸ notifyTyping()
Fires typing event.
Pure UX event.
</pre>
            <pre>
ğŸ˜€ react()
Sends reaction event.
Server broadcasts.
Everyone updates.
</pre>
            <pre>
ğŸ“œ scrollToBottom()
Uses DOM access to move scroll.
Wrapped in setTimeout so DOM finishes rendering first.
Without timeout â†’ wrong scroll height.
</pre>
            <pre>
ğŸ“… Day separators
Two helpers:

isNewDay()
Compares previous and current timestamps.
Decides whether to render: ---- Today ----

getDayLabel()
Returns:
â€¢ Today
â€¢ Yesterday
â€¢ date string
</pre>
            <pre>
ğŸ§¹ ngOnDestroy()
this.sub?.unsubscribe();
this.socketService.close();
Critical.

Prevents:
âŒ memory leaks
âŒ zombie sockets
âŒ duplicate listeners
Runs when component leaves page.
</pre>
        </div>
    </div>
</div>
<div class="container alert alert-dark card">
    <div class="row">
        <b>Websocket-component.html</b>
        <pre>
            {{htmlCode}}
        </pre>
    </div>
</div>