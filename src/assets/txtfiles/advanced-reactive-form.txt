<----------------------------------- HTML ------------------------------------->

<form [formGroup]="dynamicForm" (ngSubmit)="onSubmit()">
                    <div *ngFor="let field of formConfig" class="mb-3 mt-3">

        ðŸ‘‰ ðŸ‘‰ ðŸ”´  <!-- âœ… TEXT, EMAIL (NON-GROUP, NON-SELECT, NON-RADIO, NON-CHECKBOX) -->
                        <ng-container *ngIf="field.type !== 'group' &&
             field.type !== 'select' &&
             field.type !== 'radio' &&
             field.type !== 'checkbox' &&  isFieldVisible(field)">
                            <label class="form-label">{{ field.label }}</label>
                            <input class="form-control" [type]="field.type" [formControlName]="field.name"
                                [placeholder]="field.placeholder">

                            <!-- â³ LOADING -->
                            <small class="text-danger" *ngIf="dynamicForm.get(field.name)?.pending">
                                Checking email availability...
                            </small>

                            <!-- âŒ EMAIL EXISTS -->
                            <small class="text-danger" *ngIf="dynamicForm.get(field.name)?.errors?.['emailExists']">
                                Email already registered
                            </small>

                            <small class="text-danger" *ngIf="
          dynamicForm.get(field.name)?.invalid && !dynamicForm.get(field.name)?.errors?.['emailExists'] &&
          (dynamicForm.get(field.name)?.touched || submitted)
        ">
                                {{ field.label }} is required
                            </small>

                            <small class="text-danger" *ngIf="
    field.name === 'companyName' &&
    dynamicForm.get('companyName')?.hasError('required') &&
    (dynamicForm.get('companyName')?.touched || submitted)
  ">
                                When Employment Type is Employed
                            </small>
                        </ng-container>

            ðŸ‘‰ ðŸ‘‰ ðŸ”´   <!-- âœ… GROUP (Password + Confirm Password) -->
                        <ng-container *ngIf="field.type === 'group'" [formGroupName]="field.name">
                            <div *ngFor="let child of field.fields" class="mb-2">
                                <label class="form-label">{{ child.label }}</label>
                                <input class="form-control" [type]="child.type" [formControlName]="child.name"
                                    [placeholder]="child.placeholder">
                                <!-- âœ… Field-level error -->
                                <small class="text-danger" *ngIf="
            dynamicForm.get(field.name + '.' + child.name)?.invalid &&
            (dynamicForm.get(field.name + '.' + child.name)?.touched || submitted)
          ">
                                    {{ child.label }} is invalid
                                </small>
                            </div>

                            <!-- âœ… GROUP-LEVEL PASSWORD MISMATCH ERROR -->
                            <small class="text-danger fw-bold" *ngIf="
          dynamicForm.get(field.name)?.errors?.['passwordMismatch'] &&
          (dynamicForm.get(field.name)?.touched || submitted)
        ">
                                Password and Confirm Password do not match
                            </small>
                        </ng-container>

            ðŸ‘‰ ðŸ‘‰ ðŸ”´   <!-- âœ… SELECT -->
                        <ng-container *ngIf="field.type === 'select'">
                            <label class="form-label">{{ field.label }}</label>
                            <select class="form-control form-select" [formControlName]="field.name">
                                <option value="">-- Select --</option>
                                <option *ngFor="let opt of field.options" [value]="opt">
                                    {{ opt }}
                                </option>
                            </select>
                            <small class="text-danger" *ngIf="
          dynamicForm.get(field.name)?.invalid &&
          (dynamicForm.get(field.name)?.touched || submitted)
        ">
                                {{ field.label }} is required
                            </small>
                        </ng-container>

            ðŸ‘‰ ðŸ‘‰ ðŸ”´   <!-- âœ… RADIO -->
                        <ng-container *ngIf="field.type === 'radio'">
                            <label class="form-label d-block">{{ field.label }}</label>
                            <label *ngFor="let opt of field.options" class="me-3">
                                <input class="form-check-input" type="radio" [formControlName]="field.name"
                                    [value]="opt">
                                {{ opt }}
                            </label>
                            <br>
                            <small class="text-danger" *ngIf="
          dynamicForm.get(field.name)?.invalid &&
          (dynamicForm.get(field.name)?.touched || submitted)
        ">
                                {{ field.label }} is required
                            </small>
                        </ng-container>

            ðŸ‘‰ ðŸ‘‰ ðŸ”´  <!-- âœ… CHECKBOX -->
                        <ng-container *ngIf="field.type === 'checkbox'">
                            <label>
                                <input class="form-check-input" type="checkbox" [formControlName]="field.name">
                                {{ field.label }}
                            </label>
                            <br>
                            <small class="text-danger" *ngIf="
          dynamicForm.get(field.name)?.invalid &&
          (dynamicForm.get(field.name)?.touched || submitted)
        ">
                                You must accept the terms
                            </small>
                        </ng-container>

                    </div>
                    <button class="btn btn-primary">Submit</button>
</form>


***************************** ðŸ‘‰ ðŸ‘‰ ðŸ”µ AUTO SAVE FORM ************************************

<form [formGroup]="profileForm">
                    <ng-container>
                        <label>Name</label>
                        <input type="text" class="form-control" formControlName="name">
                    </ng-container>
                    <ng-container>
                        <label>Email</label>
                        <input type="email" class="form-control" formControlName="email">
                    </ng-container>
                    <ng-container>
                        <label>Bio</label>
                        <textarea class="form-control" formControlName="bio"></textarea>
                    </ng-container>
                    <br>
                    <p *ngIf="isSaving">ðŸ’¾ Saving draft...</p>
                    <button type="button" class="btn btn-info" (click)="clearDraft()">Clear Draft</button>
</form>


<---------------------------------- TS ------------------------------->

import { Component, OnInit } from "@angular/core";
import { RouterModule } from "@angular/router";
import {
  FormBuilder,
  FormGroup,
  Validators,
  ReactiveFormsModule
} from '@angular/forms';
import { CommonModule } from '@angular/common';
import { AbstractControl, ValidationErrors } from '@angular/forms';
import { HttpClient, HttpClientModule } from "@angular/common/http";

// async validators
import { UserApiService } from './async-validators/user-api.service';
import { emailExistsValidator } from './async-validators/email-exists.validator';

import { debounceTime, Subscription } from 'rxjs';
@Component({
  selector: "app-advanced-reactive",
  templateUrl: "./advanced-reactive.component.html",
  styleUrls: ["./advanced-reactive.component.scss"],
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, RouterModule,HttpClientModule],
})

export class AdvancedReactiveComponent implements OnInit {

  dynamicForm!: FormGroup;
  submitted = false;

ðŸ‘‰ ðŸ‘‰ ðŸ”´ // âœ… JSON CONFIG (API-driven) assume this the api response
  formConfig = [
    {
      type: 'text',
      label: 'Full Name',
      name: 'fullName',
      placeholder: 'Enter full name',
      validators: ['required', 'minLength:3']
    },
    {
      type: 'email',
      label: 'Email',
      name: 'email',
      placeholder: 'Enter email',
      validators: ['required', 'email'],
      asyncValidators: ['emailExists']
    },
    {
      type: 'group',
      name: 'password',
      validators: ['passwordMatch'],
      fields: [
        {
          type: 'password',
          label: 'Password',
          name: 'password',
          placeholder: 'Enter password',
          validators: ['required', 'minLength:6']
        },
        {
          type: 'password',
          label: 'Confirm Password',
          name: 'confirmPassword',
          placeholder: 'Enter confirm password',
          validators: ['required']
        }
      ]
    },
    {
      type: 'select',
      label: 'Country',
      name: 'country',
      options: ['India', 'USA', 'UK'],
      validators: ['required']
    },
    {
      type: 'text',
      label: 'Aadhaar Number',
      name: 'aadhaar',
      placeholder: 'Enter aadhaar',
      validators: []
    },
    {
      type: 'text',
      label: 'Green card',
      name: 'greencard',
      placeholder: 'Enter green card',
      validators: []
    },
    {
      type: 'select',
      label: 'Employment Type',
      name: 'employmentType',
      options: ['Student', 'Self Employed', 'Employed'],
      validators: ['required']
    },
    {
      type: 'text',
      label: 'Company Name',
      name: 'companyName',
      placeholder: 'Enter company name',
      validators: []   // âœ… REQUIRED will be added dynamically
    },
    {
      type: 'select',
      label: 'Applied Before?',
      name: 'appliedCase',
      options: ['No', 'Applied But Rejected'],
      validators: ['required']
    },
    {
      type: 'text',
      label: 'Specify Reason (if already rejected)',
      name: 'reason',
      placeholder: 'Enter Specific Reason',
      validators: ['required']
    },
    {
      type: 'select',
      label: 'Differently Abled Person?',
      name: 'differentlyAbledCheck',
      options: ['Yes', 'No'],
      validators: ['required']
    },
    {
      type: 'text',
      label: 'Please Specify Details',
      name: 'differentlyAbled',
      placeholder: 'Enter Specific Details',
      visibleWhen: {
        field: 'differentlyAbledCheck',
        value: 'Yes'
      },
      validators: ['required']
    },
    {
      type: 'radio',
      label: 'Gender',
      name: 'gender',
      options: ['Male', 'Female', 'Trans gender'],
      validators: ['required']
    },
    {
      type: 'checkbox',
      label: 'Accept Terms',
      name: 'terms',
      validators: ['requiredTrue']
    }
  ];
  tsCode!: string;

  constructor(private fb: FormBuilder, private userApi: UserApiService,private http: HttpClient) {
     this.http.get('../../../assets/txtfiles/advanced-reactive-form.txt', { responseType: 'text' })
      .subscribe(code => this.tsCode = code);

  }

  profileForm!: FormGroup;
  autoSaveSub!: Subscription;
  isSaving = false;

  ngOnInit() {
    ðŸ‘‰ ðŸ‘‰ ðŸ”´
    this.buildFormFromConfig(); // build form from api
    this.applyConditionalValidation();  // Country â†’ Aadhaar / Greencard
    this.applyDynamicValidators();      // âœ… Gender â†’ Greencard REQUIRED
    this.enableDisableValidators();
    this.conditionalFieldsValidators();


   ðŸ‘‰ ðŸ‘‰ ðŸ”µ /* Auto save form*/
    // âœ… 1. Build form
    this.profileForm = this.fb.group({
      name: ['', Validators.required],
      email: ['', [Validators.required, Validators.email]],
      bio: ['', [Validators.required]]
    });

    // âœ… 2. Restore saved draft
    this.restoreDraft();

    // âœ… 3. Listen for auto-save
    this.autoSaveSub = this.profileForm.valueChanges
      .pipe(
        debounceTime(1000) // wait until user stops typing
      )
      .subscribe(value => {
        this.autoSave(value);
      });
  }

  // âœ… Convert JSON to FormGroup - JSON-based Dynamic Forms
  buildFormFromConfig() {
    const formGroup: any = {};
    this.formConfig.forEach((field: any) => {

      const syncValidators = this.mapValidators(field.validators || []);
      const asyncValidators = this.mapAsyncValidators(field.asyncValidators || []);

      if (field.type === 'group') {

        const nestedGroup: any = {};

        field?.fields.forEach((child: any) => {
          nestedGroup[child.name] = [
            '',
            this.mapValidators(child.validators || [])
          ];
        });

        // âœ… Apply group-level password validator
        formGroup[field.name] = this.fb.group(
          nestedGroup,
          field.validators?.includes('passwordMatch')
            ? { validators: [this.passwordMatchValidator.bind(this)] }
            : undefined
        );

      } else {

        formGroup[field.name] = [
          '',
          syncValidators,
          asyncValidators
        ];

      }
    });

    this.dynamicForm = this.fb.group(formGroup);
  }

  // âœ… Convert string validators to Angular validators
  mapValidators(validators: string[]) {
    const formValidators = [];
    for (let rule of validators) {
      if (rule === 'required') formValidators.push(Validators.required);
      if (rule === 'email') formValidators.push(Validators.email);
      if (rule === 'requiredTrue') formValidators.push(Validators.requiredTrue);

      if (rule.startsWith('minLength')) {
        const value = Number(rule.split(':')[1]);
        formValidators.push(Validators.minLength(value));
      }
    }
    return formValidators;
  }

  // CUSTOM VALIDATION
  passwordMatchValidator(group: AbstractControl): ValidationErrors | null {
    const password = group.get('password')?.value;
    const confirmPassword = group.get('confirmPassword')?.value;
    if (!password || !confirmPassword) return null;
    return password === confirmPassword ? null : { passwordMismatch: true };
  }

  // âœ… âœ… âœ… CONDITIONAL VALIDATION (JSON + valueChanges) Conditional Validators 
  applyConditionalValidation() {
    this.dynamicForm.get('country')?.valueChanges.subscribe(country => {

      const aadhaar = this.dynamicForm.get('aadhaar');
      const ssn = this.dynamicForm.get('greencard');

      if (country === 'India') {
        aadhaar?.setValidators([
          Validators.required,
          Validators.pattern('^[0-9]{12}$')
        ]);
        ssn?.clearValidators();
        ssn?.setValue('');
      }

      else if (country === 'USA') {
        ssn?.setValidators([
          Validators.required,
          Validators.pattern('^[0-9]{9}$')
        ]);
        aadhaar?.clearValidators();
        aadhaar?.setValue('');
      }

      else {
        aadhaar?.clearValidators();
        ssn?.clearValidators();
        aadhaar?.setValue('');
        ssn?.setValue('');
      }

      // âœ… MUST CALL THIS
      aadhaar?.updateValueAndValidity();
      ssn?.updateValueAndValidity();
    });
  }

  // âœ… Async validator mapper
  mapAsyncValidators(validators: string[]) {
    const asyncValidators = [];

    for (let rule of validators) {
      if (rule === 'emailExists') {
        asyncValidators.push(emailExistsValidator(this.userApi));
      }
    }

    return asyncValidators;
  }

  // Dynamic validation
  applyDynamicValidators() {
    this.dynamicForm.get('employmentType')?.valueChanges.subscribe(type => {

      const company = this.dynamicForm.get('companyName');

      if (type === 'Employed') {
        company?.setValidators([
          Validators.required,
          Validators.minLength(3)
        ]);
      } else {
        company?.clearValidators();
        company?.setValue('');
      }

      // âœ… MANDATORY
      company?.updateValueAndValidity();
    });
  }


  onSubmit() {
    this.submitted = true;
    this.dynamicForm.markAllAsTouched();

    if (this.dynamicForm.invalid || this.dynamicForm.pending) return;

    console.log('âœ… Dynamic Form Data:', this.dynamicForm.value);
    alert('Dynamic Form Submitted Successfully!');

    // âœ… âœ… âœ… PROPER FRESH RESET
    this.resetFormFresh();
    //this.resetFormHard();
  }

  // Normal reset
  resetFormFresh() {
    // âœ… 1. Reset submitted flag FIRST
    this.submitted = false;

    // âœ… 2. Reset all values + states
    this.dynamicForm.reset();

    // âœ… 3. CLEAR conditional validators manually
    const aadhaar = this.dynamicForm.get('aadhaar');
    const greencard = this.dynamicForm.get('greencard');

    aadhaar?.clearValidators();
    greencard?.clearValidators();

    aadhaar?.updateValueAndValidity({ emitEvent: false });
    greencard?.updateValueAndValidity({ emitEvent: false });

    // âœ… 4. Reset form state properly
    this.dynamicForm.markAsPristine();
    this.dynamicForm.markAsUntouched();

    // âœ… 5. Re-attach runtime rules again
    this.applyConditionalValidation();
  }

  // HARD Reset
  resetFormHard() {
    this.submitted = false;
    this.buildFormFromConfig();       // âœ… rebuild form fresh
    this.applyConditionalValidation();
  }

  enableDisableValidators() {
    this.dynamicForm.get('appliedCase')?.valueChanges.subscribe(type => {
      const reason = this.dynamicForm.get('reason');

      if (type === 'Applied But Rejected') {
        reason?.enable();
        reason?.setValidators([
          Validators.required,
          Validators.minLength(3)]
        );
      } else {
        reason?.disable();
        reason?.reset(); // ðŸ”¥ clear value when disabled
      }
    })
  }

  conditionalFieldsValidators() {
    this.formConfig.forEach(field => {
      if (!field.visibleWhen) return;

      const dependent = this.dynamicForm.get(field.visibleWhen.field);
      const control = this.dynamicForm.get(field.name);

      dependent?.valueChanges.subscribe(value => {
        if (value === field.visibleWhen.value) {
          // SHOW â†’ enable validators
          control?.setValidators(
            this.mapValidators(field.validators || [])
          );
        } else {
          // HIDE â†’ remove value + validators
          control?.clearValidators();
          control?.reset();
        }

        control?.updateValueAndValidity();
      });
    });
  }

  isFieldVisible(field: any): boolean {
    if (!field.visibleWhen) return true;

    const dependentControl = this.dynamicForm.get(field.visibleWhen.field);
    return dependentControl?.value === field.visibleWhen.value;
  }


 ðŸ‘‰ ðŸ‘‰ ðŸ”µ // âœ… AUTO SAVE LOGIC
  autoSave(value: any) {
    // âŒ Don't save invalid form
    if (this.profileForm.invalid) return;

    this.isSaving = true;

    // simulate API / storage delay
    setTimeout(() => {
      localStorage.setItem('profileDraft', JSON.stringify(value));
      this.isSaving = false;
      console.log('ðŸ’¾ Draft auto-saved', value);
    }, 300);
  }

  ðŸ‘‰ ðŸ‘‰ ðŸ”µ // âœ… RESTORE ON LOAD
  restoreDraft() {
    const saved = localStorage.getItem('profileDraft');
    if (!saved) return;

    this.profileForm.patchValue(JSON.parse(saved), {
      emitEvent: false // ðŸ”¥ VERY IMPORTANT
    });
  }

 ðŸ‘‰ ðŸ‘‰ ðŸ”µ clearDraft() {
    localStorage.removeItem('profileDraft');
    this.profileForm.reset();
  }

 ðŸ‘‰ ðŸ‘‰ ðŸ”µ ngOnDestroy() {
    this.autoSaveSub.unsubscribe();
  }
}
